"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeExists = exports.removeHiddenKeysFromType = exports.isCoreType = exports.groups = exports.getTypesByGroups = exports.getType = void 0;

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _bi = require("react-icons/bi");

var _vsc = require("react-icons/vsc");

var _gi = require("react-icons/gi");

var _ti = require("react-icons/ti");

var _sanityPluginSchemaInspector = require("config:@andre-brdoch/sanity-plugin-schema-inspector");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

if (!Array.isArray(_sanityPluginSchemaInspector.typesToIgnore) || _sanityPluginSchemaInspector.typesToIgnore.some(function (t) {
  return typeof t !== 'string';
})) {
  throw new Error('"typesToIgnore" option of schema inspector must be an array of strings');
}

if (!Array.isArray(_sanityPluginSchemaInspector.keysToIgnore) || _sanityPluginSchemaInspector.keysToIgnore.some(function (k) {
  return typeof k !== 'string';
})) {
  throw new Error('"keysToIgnore" option of schema inspector must be an array of strings');
}

if (_sanityPluginSchemaInspector.keysToIgnore.some(function (k) {
  return ['type', 'name'].includes(k);
})) {
  throw new Error('"keysToIgnore" option of schema inspector must not include "type" or "name"');
}

var types = _schema["default"]._source.types.filter(function (t) {
  return !_sanityPluginSchemaInspector.typesToIgnore.includes(t.name);
});

var docTypes = types.filter(function (t) {
  return t.type === 'document';
}).sort(function (a, b) {
  return a.name.localeCompare(b.name);
});
var customFieldTypes = types.filter(function (t) {
  return !docTypes.includes(t);
}).sort(function (a, b) {
  return a.name.localeCompare(b.name);
});
var coreTypes = [{
  name: 'array',
  type: 'type',
  icon: _bi.BiBracket
}, {
  name: 'block',
  type: 'type',
  icon: _bi.BiCube
}, {
  name: 'boolean',
  type: 'type',
  icon: _bi.BiToggleLeft
}, {
  name: 'date',
  type: 'type',
  icon: _bi.BiCalendar
}, {
  name: 'datetime',
  type: 'type',
  icon: _bi.BiTimeFive
}, {
  name: 'document',
  type: 'type',
  icon: _bi.BiFile
}, {
  name: 'file',
  type: 'type',
  icon: _bi.BiPaperclip
}, {
  name: 'geopoint',
  type: 'type',
  icon: _bi.BiCurrentLocation
}, {
  name: 'image',
  type: 'type',
  icon: _bi.BiImage
}, {
  name: 'number',
  type: 'type',
  icon: _ti.TiSortNumerically
}, {
  name: 'object',
  type: 'type',
  icon: _bi.BiCodeCurly
}, {
  name: 'reference',
  type: 'type',
  icon: _vsc.VscReferences
}, {
  name: 'slug',
  type: 'type',
  icon: _gi.GiSnail
}, {
  name: 'string',
  type: 'type',
  icon: _bi.BiFont
}, {
  name: 'span',
  type: 'type',
  icon: _bi.BiCode
}, {
  name: 'text',
  type: 'type',
  icon: _vsc.VscTextSize
}, {
  name: 'url',
  type: 'type',
  icon: _bi.BiLinkAlt
}];
var groups = [{
  groupType: 'docTypes',
  title: 'Document Types',
  types: docTypes
}, {
  groupType: 'customFieldTypes',
  title: 'Custom Field Types',
  types: customFieldTypes
}, {
  groupType: 'coreTypes',
  title: 'Core Types',
  types: coreTypes
}];
exports.groups = groups;

var getTypesByGroups = function getTypesByGroups(groupTypes) {
  return groups.filter(function (group) {
    return groupTypes.includes(group.groupType);
  }).reduce(function (acc, val) {
    return acc.concat(val.types);
  }, []);
};

exports.getTypesByGroups = getTypesByGroups;

var getTypeFromList = function getTypeFromList(list, name) {
  return list.find(function (t) {
    return t.name === name;
  });
};

var getType = function getType(name) {
  return getTypeFromList(getTypesByGroups(['docTypes', 'customFieldTypes', 'coreTypes']), name);
};

exports.getType = getType;

var typeExists = function typeExists(name) {
  return getType(name) != null;
};

exports.typeExists = typeExists;

var isCoreType = function isCoreType(name) {
  return getTypeFromList(coreTypes, name) != null;
};

exports.isCoreType = isCoreType;

var removeKeyFromObj = function removeKeyFromObj(obj, keyToDelete) {
  // deep traverse
  for (var key in obj) {
    if (key === keyToDelete) {
      delete obj[key];
    } else if (_typeof(obj[key]) === 'object') {
      removeKeyFromObj(obj[key], keyToDelete);
    }
  }
};

var removeHiddenKeysFromType = function removeHiddenKeysFromType(type) {
  if (_sanityPluginSchemaInspector.keysToIgnore.length === 0) return type;

  var copy = _objectSpread({}, type);

  _sanityPluginSchemaInspector.keysToIgnore.forEach(function (key) {
    removeKeyFromObj(copy, key);
  });

  return copy;
};

exports.removeHiddenKeysFromType = removeHiddenKeysFromType;